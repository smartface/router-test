(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "../core/Actor", "@smartface/styler/lib/utils/merge", "@smartface/styler/lib/utils/findClassNames"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("../core/Actor"), require("@smartface/styler/lib/utils/merge"), require("@smartface/styler/lib/utils/findClassNames"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.Actor, global.merge, global.findClassNames);
    global.Stylable = mod.exports;
  }
})(this, function (module, exports, _Actor2, _merge, _findClassNames2) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = makeStylable;

  var _Actor3 = _interopRequireDefault(_Actor2);

  var _merge2 = _interopRequireDefault(_merge);

  var _findClassNames3 = _interopRequireDefault(_findClassNames2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var _findClassNames = function _findClassNames(classNames) {
    return (0, _findClassNames3.default)(classNames).reduce(function (acc, item) {
      return !item && [] || [].concat(_toConsumableArray(acc), [item.join('')]);
    }, []);
  };

  // TODO create new jsdoc type for the parameter
  /**
   * Styleable Actor HOC. Decorates specifeid component and return an actor component
   * 
   * @param {object} component - A component to decorate
   * @param {string} className - initial className for actor
   * @param {function} hooks - context's hooks dispatcher
   * 
   * @returns {Object} - A Stylable Actor
   */
  function makeStylable(_ref) {
    var component = _ref.component,
        _ref$classNames = _ref.classNames,
        classNames = _ref$classNames === undefined ? "" : _ref$classNames,
        _ref$userStyle = _ref.userStyle,
        userStyle = _ref$userStyle === undefined ? {} : _ref$userStyle,
        name = _ref.name;

    var initialClassNames = _findClassNames(classNames);
    userStyle = (0, _merge2.default)(userStyle);
    var waitedStyle = {};

    /**
     * Styable actor
     * @class
     */
    return new (function (_Actor) {
      _inherits(Stylable, _Actor);

      function Stylable() {
        _classCallCheck(this, Stylable);

        var _this = _possibleConstructorReturn(this, (Stylable.__proto__ || Object.getPrototypeOf(Stylable)).call(this, component, name));

        _this.getUserStyle = function () {
          return (0, _merge2.default)(userStyle);
        };

        _this.setSafeArea = function (area) {
          _this.safeArea = area;
          _this.isDirty = true;

          return _this;
        };

        _this.makeDirty = function () {
          _this.isDirty = true;
        };

        _this.clearDirty = function () {
          _this.isDirty = false;
        };

        _this.updateUserStyle = function (props) {
          userStyle = (0, _merge2.default)(userStyle, props);
          _this.isDirty = true;

          return _this;
        };

        _this.reset = function () {
          _this.setStyles(_this.getStyles(), true);

          return _this;
        };

        _this.setUserStyle = function (props) {
          if (typeof props === 'function') {
            userStyle = props(_this.getUserStyle());
          } else {
            userStyle = (0, _merge2.default)(props);
          }

          _this.isDirty = true;

          return _this;
        };

        _this.computeAndAssignStyle = function (style) {
          var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          var hooks = _this.hook || function (_) {
            return null;
          };

          var reduceDiffStyleHook = hooks("reduceDiffStyleHook") || null;
          style = (0, _merge2.default)(style, userStyle);

          var safeAreaProps = {};

          if (_this.safeArea) {
            var getNotEmpty = function getNotEmpty(v, y) {
              return v !== undefined ? v : y !== undefined && y || null;
            };

            var addValstoSafeAreaIfExists = function addValstoSafeAreaIfExists(val, willAdd) {
              return typeof willAdd === "number" && typeof val === "number" ? val + willAdd : willAdd;
            };
            var assigntoSafeAreaIfNotEmpty = function assigntoSafeAreaIfNotEmpty(prop) {
              return _this.safeArea[prop] !== undefined && (safeAreaProps[prop] = addValstoSafeAreaIfExists(getNotEmpty(style[prop], _this.styles[prop]), _this.safeArea[prop]));
            };

            assigntoSafeAreaIfNotEmpty("paddingTop");
            assigntoSafeAreaIfNotEmpty("paddingBottom");
            assigntoSafeAreaIfNotEmpty("paddingRight");
            assigntoSafeAreaIfNotEmpty("paddingLeft");
          }

          var diffReducer = !force && reduceDiffStyleHook ? reduceDiffStyleHook(_this.styles || {}, Object.assign({}, style)) : null;

          var rawDiff = typeof diffReducer === 'function' ? Object.keys(style).reduce(diffReducer, {}) : (0, _merge2.default)(_this.styles, style);

          if (rawDiff) {
            Object.assign(rawDiff, safeAreaProps);
            // Object.assign(style, safeAreaProps);
          }

          var beforeHook = hooks("beforeStyleDiffAssign");
          var diff = beforeHook && beforeHook(rawDiff) || rawDiff;

          var comp = name.indexOf("_") === -1 && _this._actorInternal_.component.layout ? _this._actorInternal_.component.layout : _this._actorInternal_.component;
          var hasDiff = diff !== null && Object.keys(diff).length > 0;

          //TODO: extract all specified area @cenk
          // ------------->

          var componentObjectProps = {
            "android": {},
            "ios": {},
            "layout": {}
          };

          var SCW_LAYOUT_PROPS = {
            "alignContent": "alignContent",
            "alignItems": "alignItems",
            "direction": "direction",
            "flexDirection": "flexDirection",
            "justifyContent": "justifyContent",
            "flexWrap": "flexWrap",
            "paddingLeft": "paddingLeft",
            "paddingTop": "paddingTop",
            "paddingRight": "paddingRight",
            "paddingBottom": "paddingBottom",
            "marginRight": "marginRight",
            "marginLeft": "marginLeft",
            "marginTop": "marginTop",
            "marginBottom": "marginBottom",
            "layoutHeight": "height",
            "layoutWidth": "width",
            "backgroundColor": "backgroundColor"
          };

          function componentAssign(component, key, value) {
            if (value !== null && value instanceof Object && componentObjectProps[key]) {
              Object.keys(value).forEach(function (k) {
                return componentAssign(component[key], k, value[k]);
              });
            } else {
              component[key] = value;
            }
          }

          typeof component.subscribeContext === "function" ? hasDiff && component.subscribeContext({ type: "new-styles", style: Object.assign({}, diff), rawStyle: (0, _merge2.default)(rawDiff) }) : hasDiff && Object.keys(diff).forEach(function (key) {
            try {
              if (component.layout && SCW_LAYOUT_PROPS[key]) {
                componentAssign(component.layout, SCW_LAYOUT_PROPS[key], diff[key]);
              } else {
                componentAssign(component, key, diff[key]);
              }
            } catch (e) {
              throw new Error(key + " has invalid value " + JSON.stringify(style[key]) + " " + e.message);
            }
          });
          // <-------------------

          var afterHook = hooks("afterStyleDiffAssign");
          afterHook && (style = afterHook(style));

          _this.styles = style;

          return _this;
        };

        _this.applyStyles = function () {
          var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _this.computeAndAssignStyle(waitedStyle, force = false);
          _this.clearDirty();

          return _this;
        };

        _this.setStyles = function (style) {
          var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          waitedStyle = (0, _merge2.default)(waitedStyle, style);
          _this.makeDirty();
          return _this;
        };

        _this.getStyles = function () {
          return _this.styles ? Object.assign({}, _this.styles) : {};
        };

        _this.getClassName = function () {
          return _this.classNames.join(" ");
        };

        _this.classNamesCount = function () {
          return _this.classNames.length;
        };

        _this.removeClassName = function (className) {
          return _this.removeClassNames(className);
        };

        _this.removeClassNames = function (classNames) {
          var classNamesArr = Array.isArray(classNames) ? classNames : _findClassNames(classNames);

          _this.classNames = _this.classNames.filter(function (cname) {
            return !classNamesArr.some(function (rname) {
              return cname === rname;
            });
          });
          classNamesArr.length && (_this.isDirty = true);

          return _this.getClassName();
        };

        _this.resetClassNames = function () {
          var classNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          _this.classNames = [];
          [].concat(_toConsumableArray(initialClassNames), _toConsumableArray(classNames)).forEach(_this.addClassName);
          _this.isDirty = true;

          return _this;
        };

        _this.hasClassName = function (className) {
          return _this.classNames.some(function (cname) {
            return cname === className;
          });
        };

        _this.pushClassNames = function (classNames) {
          var classNamesArr = Array.isArray(classNames) ? classNames : _findClassNames(classNames);

          if (!classNamesArr.some(_this.hasClassName)) {
            _this.classNames = [].concat(_toConsumableArray(_this.classNames), _toConsumableArray(classNamesArr));
            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.addClassName = function (className, index) {
          if (!_this.hasClassName(className)) {
            _this.classNames.splice(index, 1, className);
            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.dispose = function () {
          _this._actorInternal_.component = null;
          _this._actorInternal_ = null;
          _this.context = null;
          _this.styles = null;
          component.onSafeAreaPaddingChange = null;
          component.dispatch = null;
          component.onDispose && component.onDispose();
        };

        _this.classNames = [].concat(_toConsumableArray(initialClassNames));
        _this.styles = {};
        _this.inlinestyles = {};
        _this.isDirty = true;
        return _this;
      }

      /**
       * Sets styles
       *
       * @param {object} styles - a style object
       */


      _createClass(Stylable, [{
        key: "getInitialClassName",
        value: function getInitialClassName() {
          return initialClassNames;
        }
      }]);

      return Stylable;
    }(_Actor3.default))();
  }
  module.exports = exports["default"];
});